import queue as q
from typing import List, Tuple

from .a_star import AStarSearch


# class to represent Robot's C-space
class RobotMap:
    # ob_map is the occupancy generated by ObstacleMap
    # radius_extra_cells is the number of cells the robot takes up in each direction
    # in addition
    def __init__(
        self, ob_map: List[List[int]], radius_extra_cells: int, infl_rad_cells: int
    ):
        self.ob_map = ob_map
        self.rows = len(ob_map)
        self.cols = len(ob_map[0])

        self.map = self._jmap_from_obs_map(radius_extra_cells)
        self.infl_rad_cells = infl_rad_cells

    # use flood-fill algorithm to find the open region including (r, c)
    def _get_region(
        self, r: List[List[int]], c: List[List[int]]
    ) -> Tuple[List[List[int]], int]:
        queue = q.Queue(maxsize=0)

        # open region 2D array that indicates the
        # open region connected to (r, c) with a 1
        region = [[0 for _ in range(self.cols)] for _ in range(self.rows)]
        size = 0

        if self.map[r][c] == 0:
            queue.put((r, c))
            region[r][c] = 1
            size += 1

        while not queue.empty():
            coord_r, coord_c = queue.get()

            # check four cardinal neighbors
            for i in range(coord_r - 1, coord_r + 2):
                for j in range(coord_c - 1, coord_c + 2):
                    if self._in_map(i, j) and (i == coord_r or j == coord_c):
                        # if empty space and not checked yet
                        if self.map[i][j] == 0 and region[i][j] == 0:
                            # add to region and put in queue
                            region[i][j] = 1
                            queue.put((i, j))
                            size += 1

        return region, size

    # returns the largest contiguous region with a tile in the leftmost column
    def biggest_left_region(self):
        max_size = 0
        max_region = []
        for row in range(self.rows):
            region, size = self._get_region(row, 0)

            if size > max_size:
                max_size = size
                max_region = region

        return max_region

    # returns the largest contiguous region with a tile in the rightmost column
    def biggest_right_region(self):
        max_size = 0
        max_region = []
        for row in range(self.rows):
            region, size = self._get_region(row, self.cols - 1)

            if size > max_size:
                max_size = size
                max_region = region

        return max_region

    def regions_connected(self, regionA: List[List[int]], regionB: List[List[int]]):
        for r in range(len(regionA)):
            for c in range(len(regionA[0])):
                if regionA[r][c] != regionB[r][c]:
                    return False

                # if they share any common spaces, they're connected
                elif regionA[r][c] == 1 and regionB[r][c] == 1:
                    return True

        return False

    # returns a path between all points in the list points using A*
    # if a valid path cannot be found, returns None
    def get_path(self, points, dist_map):
        num_points = len(points)
        if num_points < 2:
            raise Exception("Path needs at least two points")

        # check if any points aren't empty
        for point in points:
            if self.map[point[0]][point[1]] == 1:
                raise Exception("The point (%d, %d) is a wall" % (point[0], point[1]))

        overall_path = []
        for n in range(num_points - 1):
            overall_path.append(points[n])

            # generate path between this point and the next one in the list
            a_star = AStarSearch(self.map, self.infl_rad_cells)

            intermediate_path = a_star(points[n], points[n + 1], dist_map)
            if not intermediate_path:
                return None

            # add to the overall path
            if n > 0:
                intermediate_path.pop(0)
            overall_path.extend(intermediate_path)

        return overall_path

    # robot_radius is how many cells from the center cell the robot takes up
    # robot_radius of 1 means robot takes up 3x3 cells
    # robot_radius of 2 means robot takes up 5x5 cells
    def _jmap_from_obs_map(self, robot_radius: int):
        jackal_map = [[0 for _ in range(self.cols)] for _ in range(self.rows)]

        for r in range(self.rows):
            for c in range(self.cols):
                if not self._open(r, c, robot_radius):
                    jackal_map[r][c] = 1
        return jackal_map

    # checks robot_radius cells outward from (r, c)
    # returns true if robot center can be located at (r, c)
    def _open(self, row, col, robot_radius):
        for r in range(row - robot_radius, row + robot_radius + 1):
            for c in range(col - robot_radius, col + robot_radius + 1):
                if self._in_map(r, c) and self.ob_map[r][c] == 1:
                    return False

        return True

    def _in_map(self, r, c):
        return 0 <= r and r < self.rows and 0 <= c and c < self.cols

    def get_map(self):
        return self.map
